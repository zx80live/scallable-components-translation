http://lampwww.epfl.ch/~odersky/papers/ScalableComponent.pdf
------------------------------------------------------------
- 3 абстракции для конструирования reusable-components:
	1) abstract type members
	2) explicit self types
	3) modular mixin composition

	эти абстракции позволяют трансформировать произвольные сборки статичных
	частей программы с жесткими ссылками между ними в систему reusable-components. Трансформация поддерживает структуру оригинальной системы.
	
- Рассматриваются два подхода:
	a) subject/observer framework
	b) compiler front-end
------------------------------------------------------------

Настоящие компоненты системы всегда являлись неуловимой целью индустрии ПО. В идеальном случае, программа должна была собирать из предварительно-написанных библиотек компонентов, когда аппаратура собиралась из предварительно произведенных чипов. В реальности, большие части ПО часто пишутся "с нуля", так что ПО является все еще более ремеслом, чем индустрия.

Компоненты в этом смысле являются простыми частями программ, которые используются в некоторых способах посредством больших частей или целого приложения. Компоненты могут принимать множество форм; они могут быть модулями, классами, библиотеками, фреймворками, процессами или web-services.
Их размер может варьироваться от нескольких до сотни тысяч строк. Они могут
быть собраны с другими компонентами посредством различных механизмов, таких как: 
	- aggregation, 
	- parametrization, 
	- inheritance, 
	- remote invocation, 
	- message passing

Важное требование к компонентам - это то что они являются reusable; т.е. то, что они должны быть применимы в контексте, отличном от того, в котором они были разработаны. В общем, они требуют, чтобы повторное использование компонента были возможным без модификации его исходного кода. Такие мрдификации являются нежелательными т.к. они имеют тенденцию к созданию проблем версионирования. Например, конфликт версий может возникать между адаптацией компонента в некоторе клиентское приложение и новой версией исходного компонента. Часто, это идет даже далее в требовании что компоненты являются распределенными и деплоенными только в бинарном виде.

Чтобы позволить безопасное повторное использование, компонент должен иметь интерфейс для обеспечения а также для необходимых сервисов везде, где происходят взаимодействия. Для поддержки гибкого повторного использования в новых контекстах, компонент должен также минимизировать "hard links", посредством которых определяются другие компоненты, которые необходимы для функционирования.

Мы утверждаем, что по крайней мере до некоторой степени, отсутствие прогресса в component software происходит из-за  недостатка в языках программирования, используемых для определения и интегрирования компонентов. Большинство существующих языков часто только ограниченны поддержкой для абстрацкии компонентов и их composition. Это справедливо в частности для statically typed языков, таких как Java и C#, в которых много сегодняшних компонентов ПО уже написаны. Пока эти языки предлагают некоторую поддержку описания для связывания интерфейсов, предоставленные сервисы компонентов, им не хватает возможности для абстрагирования от необходимых сервисов. Следовательно, большинство программных модулей написаны с жесткими ссылками на необходимые модули. Вследствие чего невозможно повторно использовать модуль в новом контексте, который усовершенствует или refactors некоторые те необходимые модули.

В идеале, должно быть возможным для поднятия произвольной системы программных компонентов с статичными данными и жесткими ссылками, в результате чего в системе с такой же структурой, но без статичных данных и жестких ссылок. (??? Ideally, it should be possible to lift an arbitrary system of software components with static data and hard references, resulting in a system with the same structure, but with neither static data nor hard references ???). Результат такого поднятия (lifting)  должно быть создание компонентов, которые являются first-class-значениями. [TODO first-class-values]. Мы идентифицировали три абстракции языка программирования, которые позволяют подобный lifting:

1) "Abstract type members" - обеспечивает гибкий способ для абстрагирования над конкретными типами компонентов. Абстрактные типы могут скрывать информацию о внутреннем содержимом компонентов, подобно их использованию в SML сигнатурах.[TODO SML signatures]. В ООП-фреймворке, где классы могут быть расширены  посредством наследования, они могут также быть использованы в качестве гибкого средства параметризации (часто называемого family polymorphism)[TODO family polymorphism]

2) "Self type annotations" - позволяют соединять программно-заданные типы к this. Это оказывается чтобы быть удобным способом для выражения необходимых сервисов компонента на уровне, где он соединяется с другими компонентами.

3) "Modular mixin composition" - обеспечивает гибкий способ для компонования компонентов и их типов. В отличие от functor application [TODO functor application], mixin composition может установить рекурсивные ссылки между взаимодействующими компонентами. Нет явного связывания между предоставляемым и запрашиваемым сервисами. Сервисы моделируются как component members. Предоставляемые и запрашиваемые сервисы сопоставляются по имени и поэтому не должны быть ассоциированы явно вручную.

Все три абстракции имеют свою теоретическую базу в vObj исчислении. [TODO vObj calculus]. Они всегдя являлись определенными и реализованными в языке Scala. Мы используем их широко в component-oriented rewrite в Scala compiter, с ободряющими результатами.

Три абстракции являются масштабируемыми, в смысле, что они могут описывать как очень маленькие, так и очень большие компоненты. Масштабируемость обеспечивается принципом, что результат композиции должен иметь такие же фундаментальные свойства, как и его составляющие. В нашем случае, компоненты соответствуют классам, и результат композиции компонентов является всегда также классом, который может иметь абстрактные члены и self-type annotation, который может быть скомпонован с другими классами, используя mixin composition. Классы на каждом уровне являются first-class values, и поэтому являются свободно конфигурируемыми.
------------------------------------------------
Концепция функтора в модульных системах SML и OCaml, обеспечивает способ абстракции над необходимыми сервисами в statically type-checked настройках. Это представляет важный шаг к правильным компонентам ПО. Однако, функторы по-прежнему предоставляют обслуживание ограничений, где они приходят к структурированным компонентам. Рекурсивные ссылки между разделенными скомпилированными компонентами не разрешены и наследование с динамическим связыванием не разрешены.

ML модули также другие формализмы компонентов представляют разграниченные слои, которые выделяют между компонентами и их составляющими. Этот подход может иметь некоторые преимущества в которых каждый формализм может быть с учетом к их специфическим требованиям и что программисты получают хороший синтаксический совет. Но это ограничивает масштабируемость компонентов системы. После всего, что является сложной системой на одном уровне может быть простым элементом на следущем уровне масштаба. Например, компилятор Scala сам по себе является конечно  нетривиальной системой, но это исправляется просто как объект, который используется как плагин для среды разработки Eclipse. Кроме того, различные экземпляры компилятора могут находиться одновременно в рантайме. Например, один экземпляр может осуществлять пересборку проекта, пока другой может делать синтаксическую проверку текущего редактируемого файла. Те экземпляры компилятора могут не иметь общего разделяемого состояния, кроме для Eclipse runtinme среды и глобальной файловой системы. В системе, где результаты композиции не являются объектами класса это является очень сложным для достижения.

Цель Scala - обеспечить расширенные конструкции для абстракций и композиция компонентов разделяется последством различных других исследовательских работ. С момента прихода Beta [TODO @see Beta 28] идея в том, что всё должно быть вкладуемым, nestable, включая классы. Для адресации проблемы выражения вложенных структур, которые охватывают различные исходные файлы, Beta обеспечивает "fragment system" - в качестве механизма для связывания программ, которые располагаются вне надлежащего языка. Это подобно тому, что сделано в аспектно-ориентированном программировании AOP (действительно, фрагмент системы используется для эмуляции AOP).

Абстрактные типы в Scala имеют тесное сходство с абстрактными типами сигнатур в модульной системе SML и OCaml, обобщая их к контексту first-class компонентов. Абстрактные типы являются также очень похожими на виртуальные типы virtual types у Beta и gbeta языков. На самом деле, виртуальные типы в Beta могут быть смоделированны точно в Scala посредством комбинаций абстрактных типов и self-type аннотаций. Виртуальные типы как обнаружено в gbeta являются более мощными, чем даже конструкции Scala и Beta, поскольку они могут быть наследованы как суперклассы. Это открывает возможности для расширенных форм и повторного использования иерархий классов, но это делает это очень сложным для проверки случайных и несовместимых переопределений overrides. Тесно связанно также является слои делегации в Caesar, семейство J's виртуальных классов и работа на вложенном наследовании для Java.

Дизайн миксинов mixins в Scala пришел из ООП линейных миксинов, но определяет mixin composition симметричным способом, подобно тому, что является найденным в mixin modules или traits. Jiazzi это расширение Java которое добавляет модульный механизм, основанный на units - мощной форме параметризированных модулей. Jiazzi поддерживает растяжимые идиомы подобно Scala, такие как возможность реализации миксинов. Jiazzi построена поверх Java, но ее модульный язык не интегрирован с Java и поэтому не используется более чем разделенный язык для linking Java code.

OCaml и Moby оба являются языками, которые комбинируют функциональный и ООП программирование, используя статическую типизацию. В отличие от Scala эти два языка начались с богатым функциональным языком, включая сложную модульную систему и затем были построены на этих сравнительно легковесных механизмах для классов.

Только тесная аналогия с self-type аннотациями в Scala может быть найдена в OCaml, где тип self является типом растяжимой записи (extensible record type), который является явно заданным или выведенным. Это дает OCaml значительную гибкость в моделировании примеров, которые являются в ином случае тяжелыми для выражения в статически типизированном языке. Но контекст, в котором self-types использованы - является различным в обоих языках. Вместо подтипов, OCaml использует систему параметрического полиморфизма с растяжимими записями. Объектная и модульная системы в OCaml сохраняются отдельно. С тех пор, как self-types найдены только в объектных системах, они играют меньшую роль в абстракции компонентов, чем в Scala.
------------------------------------------------
Конструкции для компонентной абстракции и композиции:
=====================================================
Scala соединяет ООП и ФП програмимрование в статически типизированный язык. Концептуально, она построена на Java-like ядре, даже хотя ее синтакс различается. Для того, чтобы этот фундамент стал таким как есть, были добавлены различные расширения.

Из ООП традиации пришла единая объектная модель, где каждое значение есть объект и каждая операция есть вызов метода. Из ФП традиции пришла идея, что функции являяются first-class values, и что некоторые объекты могут быть декомпонованы используя паттерн матчинг. Обе традиции объединились в концепцию новой системы типов, где классы:
	- могут быть вложенными, 
	- могут быть агрегированны используя mixin composition
	- типы являются членами класса, которые могут быть либо конкретными либо абстрактными.

Scala обеспечивает полную совместимость с Java. Ее программы компилируются в JVM байткод с .NET CLR как альтернативной реализацией. 
------------------------------------------------
Иерархия примитивных типов и классов Scala
=====================================================

	       +---------> AnyVal           - все типы значений являются производными (выводятся)
	       |             |
	       |		     +-----> {Double, Float, Long, Boolean, ...}	
	Any ---|
	       +---------> AnyRef          - все ссылочные типы являются производными (выводятся)
	               (java.lang.Object)
	                     |
	                     +-----> {Object, String, Iterable, Seq, ...}

AnyRef идентифицируется с root классом среды (java.lang.Object для JVM).
Класс All, не имеющий экземпляров и класс AllRef, который имеет null-reference как единственный экземпляр:

	AnyVal ---------------------------+
	                                  |
	                                  +----> All
	                                  |
	AnyRef --->{Seq,...}---> AllRef --+

Отметим, что value classes (AnyVal) не имеют AllRef в качестве подкласса и следовательно не имеют null в качестве экземпляра. Это дает возможность мэппить (map) value classes в Scala к примитивным типам host environment.

В данной секции мы сфокусируемся на описание конструкций языка Scala, которые направлены на дизайн и композицию компонентов. Мы концентрируем нашу презентацию на Scala 2.0, которая отличается в некоторых деталях от предыдущей версии. Описание, данное здесь является неофициальным. Теория. которая формализует ключевые конструкции Scala и доказывает их устойчивость - обеспечена vObj исчислением.
------------------------------------------------
Abstract Type Members
=====================================================
Важная проблема в компонентных системах - это как абстрактная форма требует сервисы. Существуют две принципиальные формы абстракции в языках программирования:

	1) параметризация 
	2) abstract members

Первая форма является типичной для функциональных языков, вто время как вторая форма - обычно используется в ООП. Традиционно, Java поддерживает parametrization for values, и member abstraction для операций. Более ранняя Java 5.0 с генериками поддерживает параметризацию также для типов.

Scala поддерживает оба стиля абстракции равномерно как для типов, так и для значений. Как ипы так и значения могут быть параметризованы, и оба могут быть абстрактными членами (abstract members). В оставшейся часть этой секции будут приведены - введение в ООП абстракцию в Scala и обзоры в тоже время большой части их системы типов. Мы отложим дискуссию о функциональных типах абстракций (таких как generics) к приложению, т.к. этот аспект языка является более обычный и не настолько фундаментальный для композиции в большом.

Начнем с примера, следующий класс определяет ячейки значений, которые могут быть прочитаны и записаны:

  abstract class AbsCell {
  	type T
  	val init:T
  	private var value:T = init
  	def get:T = value
  	def set(x:T):Unit = value = x
  }

Класс AbsCell не определяет тип ни параметры значения. Вместо этого он имеет абстрактный член типа T и абстрактное значение члена - init. Экземпляры этого класса могут создаваться посредством имплементации этих абстрактных членов с конкретными определениями в подклассах. Следующая программа показывает как сделать это в Scala используя анонимный класс:

  val cell = new AbsCell { type T = Int; val init = 1 }
  cell.set(cell.get * 2)

Тип значения cell является AbsCell {type T = Int }. Здесь тип класса AbsCell является увеличенным посредством refinement (уточнения) { type T = Int}. Это делает type alias cell.T = Int известный для назначения коду значения cell. Поэтому, операция определения типа T является легальной, например cell.set(cell.get * 2)
------------------------------------------------
Path-dependent types
================================================
Это также возможно для доступа объектов типа AbsCell без знания конкретной связки их type member. Например, следующий метод сбрасывает данную ячейку в ее начальное значение, независимо от ее типа значения:

  def reset(c: AbsCell):Unit = c.set(c.init)

Почему это работает? В примере выше, выражение c.init имеет тип c.T, и метод c.set имеет функциональный тип c.T => Unit. С того момента, как формальный тип параметра и конкретный аргумент типа совпадают, вызов метода является типо-корректным.

c.T является инстансом paht-dependent типа. В общем, такой тип имеет форму 
   x0, ..., xn.t 

где n >= 0, x0 описывает неизменное значение, каждый последующий xi описывает неизменное поле префикса пути x0,... xn.

Path-dependent типы полагаются на неизменность префикса пути. Ниже пример, где эта неизменность является нарушенной:

  var flip = false
  def f():AbsCell = {
  	flip = !flip
  	if(flip) new AbsCell {type T = Int; val init = 1}
 	else new AbsCell {type T = String; val init = ""}
  }
  f().set(f().get) 		// illegal!

В этом примере последуюшие вызовы f() возвращают ячейки, где тип значения являются попеременно либо Int либо String. Последний оператор в коде выше является ошибочным с того момента, как он пытается установить Int cell в String value. Система типов не признает этот оператор, т.к. вычисленный тип f().get был бы f().T. Этот тип не является хорошо сформированным, с тех пор как вызов метода f() не составлял хорошо сформированный путь.
------------------------------------------------
Type selection and singleton types
================================================
В Java, где классы могут также быть вложенными, тип вложенного класса описан посредством его префикса с именем внешнего класса. В Scala, этот тип является также выразимым, в форме 

  Outer#Inner

где Outer - это имя внешнего класса, в котором определен внутренний класс Inner. Оператор '#' описывает type selection (селекцию типа). Отметим, что это является концептуально различным от path dependent type p.Inner, где путь 'p' описывает значение, но не тип. Следовательно, тип выражения Outer#t это не правильный, если 't' является абстрактым типом, определенным в Outer.

На самом деле, path dependent types могут быть расширены к type selections. Path depended тип p.t берется как сокращенная запись для " p.type#t ". Здесь p.type является singleton type, который представляет просто объект, описанный посредством 'p'. Singleton types сами по себе являются также полезными в других контекстах, например, они способствуют объединению вызовов методов в цепочки. В качестве примера, рассмотрим класс C с методом incr, который увеличивает protected числовое поле и подкласс D от C, который добавляет decr метод для уменьшения этого поля:

  class C {
  	protected var x = 0
  	def incr: this.type = {x = x + 1; this }
  }

  class D extends C {
  	def decr: this.type = {x = x - 1; this }
  }

Затем мы можем выполнить цепочку вызовов для incr и decr методов, как в примере:

  val d = new D
  d.incr.decr

Без singleton type "this.type" это не было бы возможным, т.к. d.incr было бы типом C, который не имеет decr члена. В этом случае, this.type является подобным (covariant uses of) Kim Bruce's mytype construct.
------------------------------------------------
Parameter bounds
================================================
Мы теперь улучшим класс Cell так, что он также обеспечит метод setMax, который установит зачение ячейки в максимум от текущего значения ячейки и данного значения параметра. Мы бы хотели определить setMax так что он работал бы со всеми типами значений ячейки, допускающими оператор сравнения '<', который является методом класса Ordered. Для этого мы считаем этот класс определенным ниже (более улучшенная generic версия этого класса есть в стандартной библиотеке Scala):

  abstract class Ordered {
  	type O;
  	def < (that: O):Boolean
  	def <= (that:O):Boolean = this < that || this == that
  }

Класс Ordered имеет тип "O" и метод "<" как абстрактные члены. Второй метод "<=" определен в терминах "<". Отметим, что Scala не выделяет между именами операторов и нормальными идентификаторами. Следовательно, "<" и "<=" являются легальными именами методов. Кроме того, инфиксные операторы рассматриваются как вызовы методов. Для идентификаторов "m" и операндов выражений "e1, e2" выражение "e1 m e2"  рассмаривается как эквивалентные вызову метода "e1.m(e2)". Выражение this < that в классе Ordered это таким образом  просто более удобный способ для выражения вызова метода this.<(that).

Новый класс ячейки может быть определен с помощью способа generics используя bounded абстракций типов:

  abstract class MaxCell extends AbsCell {
  	type T <: Ordered {type O = T}
  	def setMax(x:T) = if(get < x) set (x)
  }

Здесь декларация типа T ограничена посредством верхней границы типа, который состоит из имени класса Ordered и уточнения "{type O = T}". Верхняя граница ограничивает специализацию T в подклассах для того, чтобы эти подтипы 't' типа Ordered для которых type member O типа 't' эквивалентен T.

Из-за этого ограничения, метод "<" класса Ordered является гарантированным чтобы быть применимым к получателю и аргументу типа T. Пример показывает, что ограниченный type member может сам по себе появляться в качестве части ограничений, т.е. Scala поддерживает F-boundedd polymorphism [TODO F-boundedd polymorphism]
------------------------------------------------
Modular mixin composition
================================================
После объяснения конструкций Scala для абстракций типов, мы теперь сфокусируемся на ее конструкциях для композиции классов. Примеси (mixin class composition) в Scala являются слиянием ООП linear mixin composition от Bracha, и являются более симметричным подходом примесей модулей и трейтов. Начнем с примера, рассмотрим следующую абстракцию для итераторов:

  trait AbsIterator {
  	type T
  	def hasNext:Boolean
  	def next:T
  } 

Отметим, что используем ключевое слово trait вместо class. Трейт это специальная форма аобстрактного класса, которая не имеет никаких значений параметров для конструктора. Трейты могут быть использованы во всех контекстах, где появляются другие абстрактные классы; однако, только трейты могут быть использованы в качестве примесей (mixin), см. ниже:

Трейт AbsIterator написан используя абстрактный type member T, который представляет тип элемента итератора. Он может в альтернативе выбирать generic representation - на самом деле это является тем, что это сделано в стандартной библиотеке Scala.

Далее, рассмотрим трейт, который наследует AbsIterator с методом foreach, который рпименяет текущую функцию к каждому элементу посредством итератора:

  trait RichIterator extends AbsIterator {
  	def foreach(f: T => Unit):Unit = while (hasNext) f(next)
  } 

Параметр 'f' имеет тип T => Unit, т.е. это функция, которая принимает аргументы типа T и возвращает результаты базового типа Unit.

Здесь конкретный класс итератора, который возвращает последующие символы данной строки:

  class StringIterator(s:String) extends AbsIterator {
  	type T = Char
  	private var i = 0
  	def hasNext = i < s.length()
  	def next = {val x = s.charAt(i); i = i + 1; x}
  }

Мы бы теперь хотели скомбинировать функциональность RichIterator и StringIterator в одном классе. С одиночным наследованием и только интерфейсами это является невозможным, так как оба класса содержат member implementations с кодом. Поэтому Scala обеспечивает механизм mixin-class композиции, который позволяет программисту повторно использовать the delta of class definition, т.е. все новые определения, являющиеся ненаследованными. Этот механизм делает возможным комбинировать RichIterator с StringIterator, как сделано в следующей тестовой программе. Программа выводит на экран столбец всех символов данной строки:

  object Test {
  	def main(args: Array[String]):Unit = {
  		class Iter extends StringIterator(args(0)) with RichIterator

  		val iter = new Iter
  		iter foreach println
  	}
  }

Класс Iter в функукции main сконструирован из mixin composition родительских StringIterator и RichIterator. Первый родитель называется superclass для Iter, а второй родитель называется mixin.
------------------------------------------------
Class Linearization
================================================
Классы, достижимые через транзитивное замыкание [TODO transitive closure] непосредственного наследования отношения от класса C называются базовым классом C. Благодаря миксинам наследование связи на формах базовых классов в общем являются направленным ациклическим графом. Линеаризация этого графа определяется ниже:

  Definition 2.1:
  Дан C - являющийся классом с родителями Cn with ... with C1. Линеаризация класса C - L(C) определена ниже:

                →       →     →
     L(C) = {C} + L(C1) + ... + L(Cn)
        
        →
  Здесь + описывает конкатенацию где элементы правого операнда заменяют идентичные элементы левого операнда:
           
           →           →
    {a, A} + B = a, (A + B)      if a not ∈ B
                   →
               = A + B           if a ∈ B

  Например, линеаризация класса Iter является:

    {Iter, RichIterator, StringIterator, AbsIterator, AnyRef, Any}


Линеаризация класса уточняет отношение наследования: если C является подклассом D, то C предшествует D в любой линеаризации, где оба C и D попадаются. Определение линеаризации также удовлетворяет свойству, что линеаризация класса всегда содержит линеаризацию его непосредственных суперклассов как суффикса. Например, линеаризация StringIterator это:

  {StringIterator, AbsIterator, AnyRef, Any}

которая является суффиксом линеаризации его подкласса Iter. Тоже самое не является истинным для линеаризации примесей классов. Это является также возможным, что классы линеаризации примесей класса появляются в различном порядке в линеаризации наследования класса, например линеаризация в Scala не является монотонной.
------------------------------------------------
Membership
================================================
Класс Iter наследует члены из обоих StringIteratir и RichIterator. В общем, класс получает из примеси композиции Cn with ... with C1 может определять членов сам по себе и может наследовать членов из всех родительских классов. Scala принимает конвенции Java и C# для статического переопределения методов. Таким образом возможно, что класс определяет и/или наследует некоторые методы с некоторым именем (Это может несоответствовать с этим выбором дизайна, из-за его сложности, но это является необходимым для обеспечения совместимости, например когда наследование из библиотеки Java Swing). Чтобы решить определяет ли член класса C переопределение члена родительского класса, или сосуществуют ли два как переопределенные варианты в C, Scala использует следующее определение соответствия членов, которые получены из аналогичных концепций в Java и C#:

  Definition 2.2:
  Определение члена M сопоставляет определение члена M', если M и M' связаны одним именем и соблюдается одно из следующих:

    1) Ни M ни M' являются определениями методов
    2) M и M' определяют оба мономорфных метода с эквивалентными типами аргумента
    3) M и M' определяют оба полиморфных метода с эквивалентным количеством типов аргументов T, T' и эквивалентным количеством параметров типов t, t', и T' = [t'/t]T

Определение членов классов входит в две категории: concrete и abstract. Существуют два правила, которые определяют набор членов класса, один для каждой категории:

  Definition 2.3:
  Конкретный член класса C является любым конкретным определением M в некотором классе Ci ∈ L(C), за исключением если есть предшествующий класс Cj ∈ L(C) где j < i который определяет конкретный член M' соответствующий M.

В абстрактных членах класса C это любое абстрактное определение M в некотором классе Ci ∈ L(C), за исключением если C содержит уже конкретный член M' соответствующий M, или если есть предшествующий класс Cj ∈ L(C) где j < i который определяет абстрактный член M' соответствующий M.

Это определение также определяет переопределение отношений между соответствующими членами класса C и его родителями. Во-первых, конкретное определение всегда переопределяет абстрактное определение. Во-вторых, для определений M и M' которые являются оба конкретными или оба абстрактными, M переопределяет M' если M появляется в классе, который предшествует (в линеаризации C) классу в котором M' является определенным.
------------------------------------------------
Super calls
================================================
Рассмотрим следующий класс синхронизированного итератора, который гарантирует что его операции выполнятся в взаимоисключающих способах при конкурентном вызове  из различных потоков:

  abstract class SyncIterator extends AbsIterator {
  	abstract override def hasNext: Boolean = synchronized(super.hasNext)
  	abstract override def next: T = synchronized(super.next)
  }

Чтобы получить расширенный (rich), синхронизированный итератор над строками, используется композиция примесей, включая три класса:

  StringIterator(someString) with RichIterator with SyncIterator

Эта композиция наследует два члена hasNext и next из примеси класса SyncIterator. Каждый метод оборачивает synchronized вокруг вызова соответствующего члена суперкласса.

Благодаря RichIterator и StringIterator определяет различные наборы членов, порядок в котором они появляются в примеси, не имеет значения. В примере выше, мы имеем эквивалентную запись:

  StringIterator(someString) with SyncIterator with RichIterator

Однако, существует тонкость. Класс, к которому осуществляется доступ посредством super вызова в SyncIterator является не его статически определенный суперкласс AbsIterator. Это не имело бы смысла, как hasNext и next являются абстрактными в этом классе. Вместо этого super доступ суперкласса StringIterator композиции миксинов, в которой SuncIterator принимает участие. В известном смысле, суперкласс в mixin composition переопределяет статически декларированные суперклассы в его примесях. Отсюда следует, что вызовы к super не могут быть статически разрешимыми, пока класс определен; их разрешение должно быть отложено к точке, где класс инстанцируется или наследуется. Это сделано точно посредством следующего определения:

  Definition 2.4:
  Рассмотрим выражение super.M в базовом классе C от D. Чтобы тип был правильным, это выражение должно ссылаться статически на некоторый член M от дочернего класса C. В контексте D тоже самое выражение затем ссылается на член M' кторый соответствует M и который появляется в первом возможном классе, который следует C в линеаризации D.

Наконец, отметим, что в языке подобном Java или C# super вызовы в классе SyncIterator будут неверными, точно потому что они назначают абстрактные члены из статических суперклассов. Как мы уже видели, Scala позволяет это конструировать, но это все еще имеет увереность, что класс является только использованным в контексте, где super вызовы обращабтся к членам, которые являются конкретно определены. Это принуждается посредством модификаторов abstract и override в классе SyncIterator. Пара модификаторов abstract и override в определении метода индицирует, что определение методов всё еще не является завершенным, потому что они переопределяют и используют абстрактные члены в суперклассе. Сам класс с незавершенными членами должен быть декларирован абстрактным, и его подклассы могут быть инстанцированны только один раз всеми членами, переопределенными посредством таких неполных членов, чтобы быть переопределенными.

Вызовы к super могут быть рассмотрены так, что они следуют линеаризации класса (это является важным отличием между Scala's mixin composition и multiple inheritance schemes). Например, рассмотрим другой класс, аналогичный SyncIterator с выводом всех возвращаемых элементов на экран.

  abstract class LoggedIterator extends AbsIterator {
  	abstract override def next: T = {
  		val x = super.next
  		println(x)
  		x
  	}
  }

Это можно комбинировать синхронизированный с logged iterator в mixin composition:

  class Iter2 extends StringIterator(someString) with SyncIterator with LoggedIterator

Линеаризация Iter2 будет такой:

  {Iter2, LoggedIterator, SyncIterator, StringIterator, AbsIterator, AnyRef, Any }


Поэтому класс Iter2 наследует его метод next  из класса LoggedIterator, вызов super.next в этом методе ссылается на метод next в классе SyncIterator, чей super.next вызов в конечном итоге ссылается на метод next в StringIterator. 

Если логирование следовало было включить в synchronization, это могло бы быть достигнуто посредством изменения порядка в миксинах:

  class Iter2 extends StringIterator(someString) with LoggedIterator with SyncIterator

В любом случае, вызовы метода next следут через super линеаризации класса Iter2.
------------------------------------------------
Selftype annotations
================================================
Каждый из операндов в mixin composition C0 with ... Cn должен ссылаться на класс. Механизм mixin composition не позволяет любому Ci ссылаться на абстрактный тип. Это ограничение делает это возможным чтобы статически проверять двусмысленность и переопределять конфликты в точке, где класс собран. Selftypes аннотации в Scala обеспечивают альтернативный способ ассоциации с классом с абстрактным типом. Следующий пример иллюстрирует это для generic реализации направленного графа, который абстрагируется от конкретных типов узлов:

  abstract class Graph {
  	type Node <: BaseNode

  	class BaseNode {
  		def connectWith(n:Node):Edge = new Edge(this, n)
  	}

  	class Edge(from:Node, to:Node) {
  		def source() = from
  		def target() = to
  	}
  }

Абстрактный тип Node ограничен по верхней границе посредством BaseNode чтобы выразить то, что мы хотим, чтобы узлы поддерживали метод connectWith. Этот метод создает новый инстанс класса Edge, который делает ссылку для узла-приемника с узлом-аргументом. К сожалению, этот код не скомпилируется, т.к. тип self-reference this в BaseNode и поэтому не соответствует типу Node который ожидается в конструкторе класса Edge. Таким образом, мы вынуждены констатировать каким-то образом, что идентификатор класса BaseNode должен быть выразимым как тип Node. Здесь возможный вариант кода:

  abstract class Graph {
  	type Node <: BaseNode

  	abstract class BaseNode {
  		def connectWith(n:Node):Edge = new Edge(self, n)
  		def self: Node
  	}
  	class Edge(from:Node, to:Node) {
  		def source = from
  		def target = to
  	}
  }

Эта версия класса BaseNode использует абстрактный метод self для выражения своего идентификатора как типа Node. Конкретный подкласс класса Graph должен определить конкретный класс Node для которого это будет возможным чтобы имплементировать метод self. Это проиллюстрировано в коде для класса LabeledGraph:

  class LabeledGraph extends Graph {
  	class Node(label:String) extends BaseNode {
  		def getLabel: String = label
  		def self:Node = this
  	}
  }

Этот программный паттерн появляется довольно часто когда family polymorphism комбинируется с явной ссылкой на this. Поэтому Scala поддерживает механизм для явного определения типа для this. Такой explicit selftype annotation используется в следющей версии класса Graph:

  abstract class Graph {
  	type Node <: BaseNode
  	class BaseNode requires Node { // в Scala 2.10+ это осуществляется через trait this:Node=> ...
  		def connectWith(n:Node):Edge = new Edge(this, n)
  	}

  	class Edge(from:Node, to:Node) {
  		def source = from
  		def target = to
  	}
  }

В определении
  class BaseNode requires Node {...}

класс Node вызывается selftype класса BaseNode. Когда selftype определен, он берется как тип из this внутри класса. Без selftype аннотации тип this берется как обычно чтобы быть типом самого класса. В классе BaseNode selftype это необходимость чтобы осуществлять типобезопасный вызов new Edge(this, n).

Selftypes могут быть произвольными; им не нужно, чтобы было отношение с классом определено. Устойчивость типа все еще ганантирована двумя требованиями: 

  (1) selftype класса может быть подтипом от selftypes всех его базовых классов
  (2) когда класс инстанцируется через выражение new, он проверяется, что selftype класса является supertype типа создаваемого объекта.

Selftypes были впервые представлены в vObj исчислении, главным образом в техническом смысле. Мы ожидали первоначально, что они не были бы использованы слишком часто в Scala программах, но включаение их в любом случае кажется теперь существенным в ситуациях, где family polymorphism комбинируется с явными self-ссылками. К нашему удивлению, selftypes обернулись чтобы быть ключевой конструкции для подъема статических систем для component-based систем. Это далее объясняется в секции 4.
------------------------------------------------
Service-Oriented Component Model
================================================
Представленная абстракция классов и механизм композиции формируют основу для service-oriented software component model. Программные компоненты являются элементами вычислений, которые обеспечивают хорошо определенный набор сервисов. Обычно, программный компонент не является самодостаточным; т.е. его реализация сервиса полагается на набор необходимых сервисов, обеспечиваемых другими взаимодействующими компонентами.

В нашей модели, программные компоненты соответствуют классам. Конкретные члены класса представляют предоставляемые сервисы, в то время, как абстрактные члены представляют необходимые сервисы. Композиция компонентов основана на миксинах, которые позволяют создавать большие компоненты из маленьких.

Механизм композиции mixin-классов идентифицирует сервисы с такими же именами; например, абстрактный метод 'm' может быть реализован в классе C, определяющим конкретный метод 'm' просто посредством смешивания в C. Таким образом, механизм композиции компонентов автоматически ассоциирует необходимые сервисы с предоставляемыми. Вместе с правилом, что конкретные члены класса всегда переопределяют абстрактные члены, этот принцип дает рекурсивные подключаемые компоненты, где сервисы компонента не должны быть связаны явно.

Этот подход упрощает сборку больших компонентов с маленькми рекурсвными зависимостями. Это масштабирует хорошо даже в наличии многих требуемых и предоставляемых сервисов, с тех пор как оассоциации между двумя являются автоматически выводимым компилятором. Более важное преимущество над традиционными black-box компонентами это что компоненты являются расширяемыми сущностями: они могут включаться посредством подклассов и переопределения. Они могут даже быть использованы чтобы добавлять новые сервисы для других расширенных компонентов, или для усовершенствования существующих сервисов других компонентов. В общем, эти возможности позволяют мягко инкрементально эволюционировать программный процесс.
------------------------------------------------
Case study: subject/observer
================================================
Концепция абстрактного типа особенно хорошо подходит для моделирования семейств типов, которые варьируются вместе ковариантно (covariantly). Эта концепция назвается family polymorphism. В качестве примера, рассмотрим паттерн проектирования publish/subscribe. Существует два класса участника - subject и observers. Subjects определяют метод subscribe, посредством которого оповещают всех зарегистрированных observers. Оповещение завершается посредством вызова метода notify, который определен во всех observers. Обычно, publish вызывается когда изменяется состояние subject. Может существовать несколько observers, ассоциированных с subject, и конкретный observer может наблюдать несколько subjects. Метод subscribe принимает идентификатор регистрируемого observer в качестве параметра, в то время, как конкретный метод notify у observer принимает в качестве параметра subject, который произвел оповещение. Следовательно, subjects и observers ссылается на друг друга в их сигнатурах методов.

Все элементы паттерна subject/observer содержатся в следующей системе:

  abstract class SubjectObserver {
  	type S <: Subject  //[TODO чем отличается от обычных abstract class или интерфейсов?]
  	type O <: Observer

  	abstract class Subject requires S {
  		private var observers: List[O] = List()

  		def subscribe(obs: O) = observers = obs :: observers
  		def publish = for (val obs <- observers) obs.notify(this)
  	}

  	abstract class Observer {
  		def notify(sub: S):Unit
  	}
  }

Высокоуровневый класс SubjectObserver имеет два класса-члена: один для subjects, другой для observers. Класс Subject определяет методы subscribe и publish. Он поддерживает список всех зарегистрированных observers в private переменной observers. Класс Observer определяет только абстрактный метод notify.

Отметим, что классы Subject и Observer непосредственно не ссылаются друг на друга, поскольку такие жесткие ссылки защищают covariant-расширения этих классов в клиентском коде. Вместо этого, SubjectObserver определяет два абстрактных типа S и O, которые связаны посредством соответствующего типа класса Subject и Observer. Классы subject и observer используют эти абстрактные типы для ссылок друг на друга.

Отметим, что этот класс Subject опирается на явную аннотацию selftype, которая является необходимой для осуществления вызова метода obs.notify(this) типо-корректным.

Механизм, определенный в паттерне publish/subscribe может быть использован посредством наследования от SubjectObserver, определение приложения определяет классы Subject и Observer. В качестве примера - представлен объект SensorReader, который определяет датчики в качестве subjects и экраны в качестве observers:

  object SensorReader extends SubjectObserver {
  	type S = Sensor
  	type O = Display

  	abstract class Sensor extends Subject {
  		val label:String
  		var value:Double = 0.0
  		def changeValue(v:Double) = {
  			value = v
  			publish
  		}
  	}

  	class Display extends Observer {
  		def println(s:String) = ...
  		def notify(sub:Sensor) = println(sub.label + " has value " + sub.value)
  	}
  }

Определение объекта, такого как SensorReader создает singleton class, который имеет единственный экземпляр определяемого объекта. В объекте SensorReader тип S связан с Sensor, в то время как тип O связан с Display. Следовательно, два ранее абстрактных типа являются теперь определены посредством переопределения definitions. Это "связывание себя узами брака" всегда необходимо, когда создается конкретный инстанс класса. С другой стороны, это также было бы возможным для определения абстрактного SensorReader класса, который может быть улучшен в дальнейшем в клиентском коде. В этом случае, два абстрактных типа были бы переопределены снова посредством abstract type definition:

  abstract class AbsSensorReader extends SubjectObserver {
  	type S <: Sensor
  	type O <: Display
  	...
  }

Следующая программа иллюстрирует, как объект SensorReader используется:

  object Test {
  	import SensorReader._

  	val s1 = new Sensor { val label = "sensor1" }
  	val s2 = new Sensor { val label = "sensor2" }


  	def main(args: Array[String]) = {
  		val d1 = new Display
  		val d2 = new Display
  		s1.subscribe(d1)
  		s1.subscribe(d2)
  		s2.subscribe(d1)
  		s2.subscribe(d2)

  		s1.changeValue(2)
  		s2.changeValue(3)
  	}
  }

Отметим, что наличие выражения import, которое делает члены объекта SensorReader доступными без префикса к коду в объекте Test. Выражение import в Scala является более общим, чем import в Java. Они могут быть использованы везде, где можно импортировать членов из любых объектов, а не только лишь из пакетов.

Паттерн subject/observer был изучен перед этим посредством различных групп. Решение структурно близко к нашему, но основано на виртуальных типах, которые были набросаны Thorup. Разработка в этой секции показывает посредством примера, что виртуальные типы Beta могут быть эмулированы посредством комбинации абстрактных типов Scala и явных typed self references. Другие подходы для реализации publish/subscribe паттерна основаны на обобщении mytype [TODO mytype] или на параметрическом полиморфизме [TODO parametric polymorphism], используя row-variables из OCaml чтобы моделировать расширяемые записи (extensible records).
------------------------------------------------
Case study: the Scala compiler
================================================
Компилятор Scala - scalac, содержит несколько фаз:
  1) фаза - синтаксический анализ, реализованный посредством сканнера и традиционного рекурсивно проходящего парсера. Результат этой фазы - абстрактное синтаксическое дерево (AST). 
  2) фаза - сопоставление синтаксического дерева с информацией символов и типов.
  3) фазы трансформации синтаксического дерева. Большинство трансформаций заменяют некоторые высокоуровневые Scala-specific конструкции на низкоуровневые, которые могут более непосредственно быть представлены в байткоде. Другие трансформации выполняют оптимизации, такие как inlining или tail call elimination (избавление от хвостовых вызовов). Трансформации всегда потребляют и производят дерево атрибутов.

Все фазы после синтаксического анализа работают с таблицей символов. Эта таблица сама по себе состоит из числа модулей. Некоторые из них:

  - модуль Names - представляет имена символов. Имя представлено объектом, состоящим из индекса и длины, который индексирует ссылки на глобальный массив, котором сохраняются все символы всех имен. Хеш-map гарантирует, что имена являются уникальными, т.е. эти эквивалентные имена всегда представлены посредством одного и того же объекта.

  - модуль Symbols - представляет символы, соответствующие определениям сущностям, таким как классы, методы, переменные и т.д. в Scala и Java модулях.

  - модуль Types - представляет типы

  - модуль Definitions - содержит глобально видимые символы для определений, которые имеют специальное значение для Scala компилятора. Примеры являются значениями Scala классов, верхние и нижние классы scala.Any и scala.All или boolean значения true и false.

  - модуль Scope - представляет локальные scopes и наборы классов у членов классов.

Структура этих модулей является сильно рекурсивной. Например, каждый символ имеет тип и некоторый тип также имеет символ. Модуль Definitions создает символы и типы, и, в свою очередь, используется в определенных операциях в модуле Types. Ссылки между модулями вовлекают доступы членов, создания обхектов, но также и наследование. Например, типы большинства символов являются lazily created, так что forward references в определениях могут быть поддержаны  и классом библиотеки, и файлами исходников, которые могут быть загружены по требованию. Это достигается посредством инициализации типов символов через специальный "lazy types", который заменяет себя c правильным значением типа символа во время первого доступа к нему. Lazy types имеют дело с динамикой компиляции вместо структуры типа;  следовательно, они определяются вне модуля Types, даже хотя их наследуют из класса Type.
------------
State of art
============
В предыдущей версии реализации компилятора Scala все модули, описанные выше, были реализованы как top-level классы (реализованы в Java), которые содержали статические члены и данные. Например, содержание имен хранилось в статическом массиве в классе Names. Также, глобальные символы хранились в статических данных в классе Definitions. Эта техника имела преимущества в том, что она поддерживала сложные рекурсивные ссылки. Но это также имело два недостатка:

  1) Во-первых, так как все ссылки между классами были жесткими hard links, мы не могли относиться к классам компилятора как к компонентам, которые можно было бы комбинировать с другими различными компонентами. Это в действительности предотвращало кусочные расширения или адаптации компилятора.
  2) Во-вторых, т.к. компилятор работал с изменяемыми (mutable) статическими структурами данных, он не был вхож (re-entrant), т.е. у него не было возможности для выполнения в нескольких конкурентных средах компилятора на одной JVM. Это было проблемой для использования компилятора Scala в IDE такой как Eclipse. Эта проблема является также не новой. Например, компиляторы Java javac и JaCo имеют структуру, аналогичную компилятору scalac. В этих компиляторах статические структуры данных и статические ссылки компонентов избегались посредством использования паттерна проектирования, который параметризировал компоненты компилятора с контекстом. Контекст маппился из реализаций идентификаторов компонентов (объектов). Компоненты компилятора использовали контекст для доступа к взаимодействующим в рантайме компонентам. (т.е. context - это глобальный ресурс для разделенных данных).
     
Этот подход делает возможным запускать несколько компиляторов в одной VM просто посредством создания различных контекстов с независимыми инстанциациями компонентов компилятора. С другой стороны, существуют несколько недостатков. Прежде всего, простое решение, подобно использованному в javac, моделирует контексты как maps из имен объектов. Этот подход отностится к динамической типизации и таким образом статически небезопасен. Паттерн проектирования Context/Component в JaCo использует комбинацию репозитория объектов и абстрактной фабрики  для моделирования контекста. Этот паттерн обеспечивает статическую типо-безопасность, но ассоциирован с относительно сложным накладным протоколом. Например, 30000 строк кода в JaCo включает 600 строк кода просто для определений контекста и более чем 1200 строк кода для фабрик объектов, не считая кода с текущими компонентами компилятора, которые используют контексты и фабрики. Контексты также ломают инкапсуляцию, т.к. им необходимо, чтобы структуры данных упаковывались во вне классов, которые имеют к ним доступ.

За пределами protocol overhead, задачи статической типизации и инкапсуляци существует всегда риск для нарушения паттернов программирования, поскольку не существует способа, заставляющего проектировать статически. Например, два инстанса компилятора выполняются одновременно, и первая таблица имени выделена на запуск компилятора, это привносит важное, что ссылка имен на другой инстанс компилятора сохранена отдельно. В противном случае, имя может индексировать таблицу, которая не сохраняет ее символы, но нектороые произвольне символы. Эта изоляция не может гарантироваться статически.

  // Listing 1: scalac's symbol table structure
  class SymbolTable {
  	class Name { ... }
  	// name specific operations

  	class Type { ... }
  	// subclasses of Type and type specific operations

  	class Symbol { ... }
  	// subclasses of Symbol and symbol specific operations

    object definitions { /* global definitions */ } 
    // other elements
  }

Другое решение, данной проблемы - использование языков программирования, обеспечивающих конструкции для композиции компонентов и абстракций. Например, функторы в SML модульной системе могут быть использованы для имплементации component-based systems где взаимодействия компонентов не заданы hard-coded. С другой стороны, функторы либо являются first-class либо higher-order. Следовательно, они не могут использоваться для создания новых компиляторво из динамически обеспечиваемыми компонентами. Другие модульные системы, подобные MzScheme's Units являются достаточно выразительными чтобы позволить это, но они являются часто только динамически типизируемыми, не дающими гарантиями в compile-time. Обычно ООП языки, такие как Arch-Java, Jiazzi и ComponentJ являются статически типизированными и обеспечивают хорошую поддержку для создания и композиции generic software components, но их система типов не является достаточно выразительной для полного изолирования reentrant систем [TODO reentrant systems]. Модульная система Keris может обеспечить строгое разделение множества reentrant инстансов компилятора, но без поддержки first-class модулей, которые необходимы чтобы число одновременно запущенных инстансов компилятора было статически известным.

------------------------------------------
A simple reentrant compiler implementation
==========================================
Для переписывания компилятора Scala мы нашли другое решение, являющееся типобезопасным и использующее само по себе элементы языка Scala. Первый шаг по направлению к этому решению - мы представили вложенные классы для выражения локальной структуры. Упрощенная версия компонента таблицы символов в компиляторе scalac - будет уточнена позже - показана в Listing 1.

Здесь, классы Name, Symbol, Type и объект Definitions являются все членами класса SymbolTable. Весь компилятор (который мог бы быть структурирован аналогично) может иметь доступ к определениям в этиом классе посредством наследования от него:

  class ScalaCompiler extends SymbolTable { ... }

В этом случае, мы пришли к компилятору без статических определений. Компилятор теперь является спроектированным для повторного использования (re-entrant). Кроме того, типы членов различных инстансов являются изолированными друг от друга, что дает хорошую степерь типобезопасности. Рассмотрим, например, сценарий, где два инстанса "c1" и "c2" компилятора Scala сосуществуют вместе.

  val c1 = new ScalaCompiler
  val c2 = new ScalaCompiler

Имена, созданные инстансом c1 компилятора имеют path-dependent тип c1.Name, в то время как имена, созданные c2 имеют тип c2.Name. После этого эти два типа являются несовместимыми, проблематика назначения, такая как следующая, могла бы быть исключена:

  c1.definitions.AllClass.name = c2.definitions.AllClass.name // illegal!
---------------------------------------------  
Component based implementation
=============================================
Код, приведенный выше, имеет очень существенный недостаток: он является большой монолитной программой и таким образом реально не является component-ориентированным! Действительно, весь код таблицы символов (примерно 4000 строк) является теперь размещенным в одном исходном файле. Это ясно становится непрактично для больших программ. Тем не менее, в классе Symbol единственное требование - ссылаться на соответствующий класс Type, который принадлежит к тому же инстансу компилятора, но который определен в другом исходном файле.

Существуют несколько возможных решений для этой проблемы. Решение, которое мы выбрали, представлено в листинге 2. Оно использует явный selftype для выражения требуемых сервисов для компонента.

  // Listing 2: Symbol table components with required interfaces
  abstract class Types requires(Types with Names with Symbols with Definitions) {
  	class Type { ... }
  	// subclasses of Type and type specific operations
  }

  abstract class Symbols requires (Symbols with Names with Types) {
  	class Symbol { ... }
  	// subclasses of Symbol and symbol specific operations
  }

  abstract class Definitions requires (Definitions with Names with Symbols) {
  	object definitions { ... }
  }

  abstract class Names {
  	class Name { ... }
  	// name specific operations
  }

  class SymbolTable extends Names with Types with Symbols with Definitions

  class ScalaCompiler extends SymbolTable with Trees with ...

Класс Types содержит иерархию классов, укоренившихся в классе Type а также операции, которые связанны с типами. Это идет с явным selftype, который является пересечением типа от всех классов, необходимых для Types. Кроме Types самого по себе, эти классы являются Names, Symbols и Definitions. Члены этих классов являются таким образом доступными в классе Types. Например, класс Types может писать this.Symbol или короче просто Symbol для члена класса Symbol необходимого класса Symbols.

Схема для класса другой таблицы символов следует одна для всех типов. В каждом случае, все необходимые классы перечислены как операнды типа пересечения в явной selftype аннотации. Весь класс таблицы символов - это затем просто миксин композиция этих компонентов. Рис. 2 иллюстрирует этот принцип. ДЛя каждого компонента он отображает предоставляемые классы а также классы, которые являются необходимыми из других компонентов. Классы представлены прямоугольниками, определения объектов представлены овалами. Комбинация всех компонентов через композицию миксинов дает полностью self-contained компонент без любых необходимых классов. Этот класс представляет нам завершенный инстанс абстракции таблицы символов.

Представленная схема является статично типо-безопасной, и обеспечивает явную нотацию для выражения необходимых, а также обепечиваемых интерфейсов компонента. Это является кратким, т.к. неявное связывание, например с помощью передачи параметров, если необходимо. Это обеспечивает превосходную гибкость для структурирования компонентов. На самом деле это позволяет поднять произвольные структуры модулей со статическими данными и жесткими ссылками в компонентной системе.

------------------------------------------------
Variants
================================================
Granularity of dependency specifications.

Представленная схема не является единственно возможным решением. Возможно несколько вариантов, которые различаются тем, как в них абстрагируются требуемые компоненты. Например, это может быть более кратко, но менее точно в предположении selftype для каждого класса SymbolTable таблицы символов само по себе. Например:

  class Types requires SymbolTable { ... }

Это может также характеризовать необходимые сервисы более детально используя абстрактный тип и значение членов, например:

  class Types {
  	type Symbol <: SymbolInterface
  	type Name <: NameInterface
  	// other required types

  	def newValue(name:Name):Symbol
  	// other required values

  	class Type { ... }
  	...
  }

Это может таким образом сузить необходимые сервисы к произвольному набору членов компонента, в то время как предыдущее решение могло требовать компоненты только как целиком. Цена оплаты для точности - это потеря краткости, поскольку границы абстрактных типов, таких как SymbolInterface в коде выше должны быть определены явно. Кроме того, абстрактные типы не могут быть наследованы, поскольку абстрактные типы в Scala не могут быть суперклассами или миксинами.

Hierarchical organization of components
Во всех вариациях, таблица символов сама по себе является результатом миксин композиции всех ее составляющих классов. С системной точки зрения, все компоненты таблицы символов определены на одном уровне. Но это является также возможным для определения подсистем, которые могут быть вложеными в другие компоненты с помощью аггрегации. В качестве примера - компонент фазы парсера компилятора scalac:

  class ParserPhase extends Lexical with Syntactic {
  	val compiler: Compiler
  }

Здесь, подкомпоненты Lexical и Syntactic структурированы одинаково, чтобы компоненты таблицы символов с выражением self-типами требующихся компонентов. Фаза синтаксического анализа также необходима для доступа компилятора как целого, например для reporting error или для конструирования синтаксических деревьев. Эти доступы завершаются через поле члена компилятора, которое является абстрактным в классе ParserPhase. Соответствующая интеграция объекта фазы парсера в компиляторе scalac приведена в ниже:

  class ScalaCompiler extends SymbolTable with Trees {
  	object parserPhase extends ParserPhase {
  		val compiler: ScalaCompiler.this.type = ScalaCompiler.this //[TODO this.type]
  	}
  	...
  }

Класс ScalaCompiler определяет инстанс класса ParserPhase в котором поле compiler связано с окружающим ScalaCompiler инстансом сама по себе. Тип этого поля является типом-синглетоном ScalaCompiler.this.type, который имеет как только член текущего инстанса ScalaCompiler. Аннотация типа синглетона является необходимой, поскольку ParserPhase содержит члены, которые ссылаются на типы, определенные в ScalaCompiler. В качестве примера - тип Tree абстрактного синтаксического дерева, который ScalaCompiler наследует от класса Trees. Чтобы соединить дерево, сгенерированное фазой парсера с поздними фазами, проверка типов необходима чтобы знать эквивалентность типа:

  parserPhase.compiler.Tree = Tree

в контексте ScalaCompiler.this. Аннотация типа синглетона задает ScalaCompiler.this как альяс для ScalaCompiler.this.parserPhase.compiler и поэтому проверяет равенство выше. 
------------------------------------------------
Compinent adaptation
================================================
Новая архитектура компилятора делает адаптацию очень простой. В качестве примера рассмотрим логирование. Давайте скажем, мы хотим логировать каждое создание символа или типа в компиляторе Scala. Логирование вовлекает запись информации в некоторый выходной канал log типа java.io.PrintStream. Ключевой момент это то, что мы хотим расширить существующий компилятор функциональностью логирования. Чтобы сделать это, мы не должны модифицировать исходный код компилятора. Мы также не хотим запрашивать compiler writer для того чтобы иметь запланированное расширение логирования посредством обеспечения хаков. Подобные хаки имеют тенденцию к ухудшению ясности кода, поскольку они смешивают раздельные проблемы в одном классе. Вместо этого мы используем подклассинг для добавления функциональности логирования к существующему классу, например:

  abstract class LogSymbols extends Symbols {
  	val log: java.io.PrintStream

  	override def newTermSymbol(name: Name): TermSymbol = {
  		val x = super.newTermSymbol(name)
  		log.println("creating term symbol " + name)
  		x
  	}
  	// similarly for all other symbol creations
  }

Аналогично, это может определять подкласс LogTypes класса Types для логирования всех созданий типов.

Следующий вопрос - как инжектить поведение логирования внутрь существующей системы. Поскольку весь компилятор Scala определен как одиночный класс, это прямое применение миксин композиции:

  class LoggedCompiler extends ScalaCompiler with LogSymbols with LogTypes {
  	val log: PrintStream = System.out
  }

  //[TODO idea for slick profile!]

В миксин композиции новая имплементация newTermSymbol в классе LogSymbols переопределяет имплементацию такого же метода, который определен в классе Symbol и который наследуется классом ScalaCompiler. Наоборот, абстрактные члены названы log в классах LogSymbols и LogTypes - заменены посредством конкретного определения log в классе LoggedCompiler.

Эта абстракция может казаться тривиальной. Но отметим, что в классических архитектурах систем со статическими компонентами и жесткими ссылками это могло бы быть невозможным. Для таких архитектур, аспектно-ориентированное программирование предлагает альтернативное решение, которое основано на перезаписи кода. На самом деле, наша архитектура компонентов может справиться с некоторыми сценариями, для которых АОП предлагало как технику выбора. Другие примеры кроме логирования - это синхронизация, security checking или выбор представления данных. Более общими словами, наша архитектура может обработать все before, after и around advice on method reception pointcut designators [TODO pointcut designators]. Это представление только одного инстанса pointcut designators, обеспеченных языком, таким как AspectJ. Поэтому в общем АОП являются очевидно более мощной, чем наша схема. С другой стороны, наша сзема имеет преимущество, что она статически типизирована и что область (scope) и порядок advice могут быть точно контроллированны используя семантику миксин композиции.
------------------------------------------------
Discussion
================================================
Мы идентифицировали три строительных блока для конструирования компонентов повторного использования:
  1) abstract type members
  2) explicit selftypes
  3) symmetric mixin composition [TODO symmetric mixin composition]

Три строительных блока выли формализованы в vObj исчислении и были реализованы в Scala. Scala также является языком, в котором все примеры программ и case studies этой статьи были написаны. Это представляет таким образом конкретный эксперимент, который проверяет представленные здесь принципы конструирования в диапазоне приложений, написанных многими различными людьми.

Но Scala является, конечно, не только возможным дизайном языка, который позволяет такие конструкции. В этой секции мы попробуем обобщить из конкретных свойств Scala, в целях выявления, какие языковые конструкции являются важным значением для достижения системы масштабируемых и динамических компонентов. Мы предполагаем, во всей дискуссии строго и статически типизированные объектно ориентированные языки. Ситуация является немного различной для динамически типизированных языков и является также различной для функциональых языков с ML-подобной модульными системами.

Первая важная конструкция языка - это вложенность классов. Поскольку вложенность классов является уже поддерживаемой посредством мейнстреймовых языков, мы пропустили их из нашей дискуссии далее, но это, тем не менее, важно. Это является основным средством для агрегации и инкапсуляции. Без этого мы бы могли компоновать только системы, состоящие из полей и методов, но не системы, содержащие сами классы. Сказать иначе, каждому классу придется быть либо базовым классом, либо миксином из top-level системы (в этом случае это могло бы иметь только один инстанс на top-level инстанциацию), или это могло бы быть молностью внешним для этой системы (в этом случае это не имело бы доступ никаких скрытых в системе).


------------------------------------------------
================================================
(enable word-wrap in sublime)

#33 [TODO first-class-values]
#35 [TODO SML signatures]
#35 [TODO family polymorphism]
#39 [TODO functor application]
#41 [TODO vObj calculus]
#49 [TODO @see Beta 28]
#195 [TODO F-bounded polymorphism]
#243 [TODO transitive closure]
#427 [TODO чем отличается от обычных abstract class или интерфейсов?]
#501 [TODO mytype]
#501 [TODO parametric polymorphism]
#550 [TODO reentrant systems] - reentrant - повторно используемый
#642 [TODO this.type]
#676 [TODO idea for slick profile!]:
	можно вместо cake паттерна использовать абстрактный тип val driver, который перепределять в контексте использования, типа:

	abstract class UserService {
		val driver:JdbcDriver
	}

	class ProductionUserService extends UserService {
		val driver = play.slick.driver
	}
	class TestUserService extends UserService {
		val driver = h2.slick.driver
	}
#680 [TODO pointcut designators]
#687 [TODO symmetric mixin composition]